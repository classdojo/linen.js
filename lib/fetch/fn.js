// Generated by CoffeeScript 1.6.2
(function() {
  var FnFetch, dref, hashObject, type, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  dref = require("dref");

  hashObject = require("../utils/hashObject");

  type = require("type-component");

  FnFetch = (function(_super) {
    __extends(FnFetch, _super);

    function FnFetch() {
      _ref = FnFetch.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    /*
    */


    FnFetch.prototype.fetch = function(payload, next) {
      var d;

      if (payload.body) {
        d = this._pluckOutFetchableFields(payload);
        payload.currentData = d;
      }
      payload.field = this.field;
      return this._fetch(payload, next);
    };

    /*
    */


    FnFetch.prototype._pluckOutFetchableFields = function(payload) {
      var d, field, unusableKeys, usable, v, _i, _len, _ref1;

      unusableKeys = [];
      d = dref.get(payload.body, this.field.path);
      if (type(d) !== "object") {
        return d;
      }
      usable = {};
      _ref1 = this.field.allFields;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        field = _ref1[_i];
        if (field.canFetch(payload.model)) {
          continue;
        }
        v = d[field.name];
        if (v == null) {
          continue;
        }
        usable[field.name] = v;
      }
      return usable;
    };

    /*
    */


    FnFetch.prototype._fetch = function(payload, next) {
      var currentHash, method, _ref1,
        _this = this;

      method = payload.method;
      if (/put/.test(payload.method)) {
        if (type(payload.currentData) === "object" && !Object.keys(payload.currentData || {}).length) {
          return next();
        }
      }
      return payload.model._memoizer.call(currentHash = this._getPayloadHash(payload), (_ref1 = this.field.options.memoize) != null ? _ref1 : {
        maxAge: 1000 * 5
      }, next, function(next) {
        var fn;

        _this._fetch(payload, next);
        if (!(fn = _this.field.options.fetch[method])) {
          return next(new Error("method \"" + method + "\" on \"" + _this.field.path + "\" doesn't exist"));
        }
        return fn.call(payload.model, payload, function(err, result) {
          if (result == null) {
            result = {};
          }
          return setTimeout((function() {
            if (err != null) {
              return next(err);
            }
            _this.field.reset(payload.model, result);
            payload.model._memoizer.replaceHash(currentHash, _this._getPayloadHash(payload));
            return next();
          }), 0);
        });
      });
    };

    /*
      used for memoizing responses
    */


    FnFetch.prototype._getPayloadHash = function(payload) {
      return hashObject({
        data: payload.method !== "get" ? this._flattenModelValues(payload.model) : void 0,
        method: payload.method,
        path: this.field.path,
        query: payload.query
      });
    };

    /*
    */


    FnFetch.prototype._flattenModelValues = function(model) {
      var d;

      return d = model.schema.toJSON(model, {
        fields: this.field.allFields
      });
    };

    return FnFetch;

  })(require("./base"));

  module.exports = FnFetch;

}).call(this);

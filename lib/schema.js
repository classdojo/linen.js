// Generated by CoffeeScript 1.6.2
(function() {
  var Model, Schema, Validator, async, bindable, dref, getMapper, outcome, parseSchemaOps, type, _;

  bindable = require("bindable");

  Model = require("./model");

  type = require("type-component");

  Validator = require("./validator");

  _ = require("underscore");

  dref = require("dref");

  outcome = require("outcome");

  async = require("async");

  getMapper = require("./map/factory");

  Schema = (function() {
    /*
    */
    function Schema(options) {
      var field, _i, _len, _ref;

      this.options = options;
      this.fields = options.fields;
      this.name = options.name;
      this.linen = options.linen;
      this.path = options.path;
      this.fieldNames = [];
      this._fieldsByKey = {};
      _ref = this.fields;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        field = _ref[_i];
        this._fieldsByKey[field.name] = field;
        this.fieldNames.push(field.name);
        field.parent = this;
      }
    }

    /*
    */


    Schema.prototype.init = function() {
      var field, _i, _len, _ref;

      this.validator = new Validator(this);
      this.mapper = getMapper(this);
      _ref = this.fields;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        field = _ref[_i];
        field.init();
      }
      return this;
    };

    /*
    */


    Schema.prototype.model = function(data) {
      var key, model;

      if (data == null) {
        data = {};
      }
      if (type(data) === "string") {
        data = {
          _id: data
        };
      }
      model = new Model(this, {
        _id: data._id
      });
      model.reset(this.map(model, data));
      for (key in this._methods) {
        model[key] = this._methods[key];
      }
      return model;
    };

    /*
     fetch a particular field - this is called
     once a property is watched
    */


    Schema.prototype.fetchField = function(model, fieldName, next) {
      var _ref;

      return (_ref = this.field(fieldName)) != null ? _ref.fetch(model, next) : void 0;
    };

    /*
     fetch the particular model
    */


    Schema.prototype.fetch = function(model, next) {
      return this.virtuals.fetch(model, next);
    };

    /*
     fetch ALL the fields in a given model
    */


    Schema.prototype.fetchAll = function(model, next) {
      var _this = this;

      return this.fetch(model, function() {
        return async.forEach(_this.fields, (function(field, next) {
          return field.fetchAll(model, next);
        }), next);
      });
    };

    /*
    */


    Schema.prototype.persist = function(model, changed) {};

    /*
     returns a field
    */


    Schema.prototype.field = function(property) {
      var field, path;

      if (property == null) {
        property = "";
      }
      path = property.split(".");
      field = this._fieldsByKey[path.shift()];
      if (field && path.length) {
        return field.field(path.join("."));
      } else {
        return field;
      }
    };

    /*
     maps to the proper data type
     TODO - default, g/s
    */


    Schema.prototype.map = function(model, data) {
      var field, _i, _len, _ref;

      data = this.mapper.map(model, data);
      if (this.fields.length) {
        if (!data) {
          data = {};
        }
        _ref = this.fields;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          field = _ref[_i];
          data[field.name] = field.map(model, data[field.name]);
        }
      }
      return data;
    };

    /*
    */


    Schema.prototype.validate = function(data, next) {
      var _this = this;

      return this.validator.validate(data, function(err) {
        if (err) {
          err.message = "'" + _this.name + "' " + err.message;
          return next(err);
        }
        return _this._validateFields(data, next);
      });
    };

    /*
    */


    Schema.prototype._validateFields = function(data, next) {
      var _this = this;

      return async.forEach(this.fields, (function(field, next) {
        return field.validate(dref.get(data, field.name), next);
      }), next);
    };

    /*
     parse a definition. Something like:
    
     {
      name: "string",
      address: {
        $type: "string"
      },
      $fetch: function() {
    
      }
     }
    */


    return Schema;

  })();

  parseSchemaOps = function(definition, name, linen, path) {
    var fieldOps, ops, property, pt, schemaOps, schemaOptions, t;

    if (path == null) {
      path = [];
    }
    ops = {};
    schemaOps = {
      name: name,
      linen: linen,
      path: path.join("."),
      fields: []
    };
    if ((t = type(definition)) === "array") {
      ops = definition[0];
      ops.collection = true;
    } else if (t === "object") {
      _.extend(ops, definition);
    } else if (t === "string") {
      ops.$type = definition;
    }
    schemaOptions = {};
    for (property in ops) {
      if (property.substr(0, 1) === "$") {
        schemaOps[property.substr(1)] = ops[property];
      } else {
        pt = path.concat(property);
        fieldOps = parseSchemaOps(ops[property], property, linen, pt);
        schemaOps.fields.push(new Schema(fieldOps));
      }
    }
    return schemaOps;
  };

  module.exports = function(options, name, linen) {
    return new Schema(parseSchemaOps(options, name, linen)).init();
  };

}).call(this);

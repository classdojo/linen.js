// Generated by CoffeeScript 1.6.2
(function() {
  var Collection, Field, comerr, type, verify;

  type = require("type-component");

  verify = require("verify")();

  comerr = require("comerr");

  Collection = require("./collection");

  Field = (function() {
    /*
    */
    function Field(property, options, schema, parent) {
      this.property = property;
      this.schema = schema;
      this.parent = parent != null ? parent : null;
      this.linen = schema.linen;
      this.options = this._setProperties(options);
    }

    /*
    */


    Field.prototype.path = function() {
      var p, path;

      if (this._path) {
        return this._path;
      }
      path = [];
      p = this;
      while (p) {
        path.push(this.property);
        p = p.parent;
      }
      return this._path = path.join(".");
    };

    /*
     validates whether the value is correct based on the field
     definition
    */


    Field.prototype.validate = function(model) {
      var errors, v, value, values, _i, _len;

      value = model.get(this.path());
      errors = [];
      if (this.options.$multi) {
        if (!(value != null ? value.__isCollection : void 0)) {
          errors.push(new comerr.Invalid("" + this.property + " must be a collection"));
        } else {
          values = value.source();
        }
      } else {
        values = [value];
      }
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        v = values[_i];
        if (!this._test(v) && (v !== void 0 || this.options.$required)) {
          errors.push(new comerr.Invalid("'" + this.property + "' is invalid", {
            field: this
          }));
        }
        if (this.options.$ref && !((v != null ? v.__isModel : void 0) && v.schema.name !== this.options.$ref)) {
          errors.push(new comerr.Invalid("'" + this.property + "' must be type " + this.options.$ref));
        }
      }
      return errors;
    };

    /*
     saves a value if there's a virtual method for it. Otherwise
     nothing really happens
    */


    Field.prototype.save = function(value) {};

    /*
     maps a value based on its type - this happens only once
    */


    Field.prototype.map = function(value) {
      var def;

      def = this._default(value);
      if (this.options.$map) {
        def = this.options.$map;
      }
      if (this.options.$multi) {
        return new Collection(this);
      }
      if (!this.options.$ref) {
        return value;
      }
      return this.linen.model(this.options.$ref, value);
    };

    /*
    */


    Field.prototype._default = function(value) {
      if (!this.options.$default) {
        return value;
      }
      if (type(this.options) === "function") {
        return this.options.$default();
      }
      return this.options.$default;
    };

    /*
    */


    Field.prototype._setProperties = function(options) {
      var ops, t;

      ops = {};
      this.children = new Field.Fields(this.schema, this);
      if ((t = type(options)) === "string") {
        ops.$type = options;
      } else if (t === "array") {
        ops.$multi = true;
        ops = options[0];
      } else {
        ops = options;
      }
      this._test = this._getValueTester(ops);
      if (!ops.$type && !ops.$ref) {
        this.children.addFields(ops);
      }
      return ops;
    };

    /*
    */


    Field.prototype._getValueTester = function(ops) {
      var k, key, tester,
        _this = this;

      if (ops.$test) {
        return ops.$test;
      }
      tester = verify.tester();
      for (key in ops) {
        k = key.substr(1);
        if (!!tester[k]) {
          tester[k].apply(tester, toarray(ops[key]));
        }
      }
      return function(value) {
        return tester.test(value);
      };
    };

    return Field;

  })();

  module.exports = Field;

}).call(this);

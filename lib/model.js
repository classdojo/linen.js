// Generated by CoffeeScript 1.6.2
(function() {
  var asyngleton, cstep, dref, outcome, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  dref = require("dref");

  outcome = require("outcome");

  cstep = require("cstep");

  asyngleton = require("asyngleton");

  _ = require("underscore");

  module.exports = function(builder, Model) {
    var LinenModel, linen;

    linen = builder.linen;
    return LinenModel = (function(_super) {
      __extends(LinenModel, _super);

      function LinenModel(data) {
        if (data == null) {
          data = {};
        }
        if (typeof data === "string") {
          data = {
            _id: data
          };
        } else {
          data = data;
        }
        this._o = outcome.e(this);
        LinenModel.__super__.constructor.call(this, data);
        this._setupRefs();
        this._update = {};
        this._initialized = true;
      }

      /*
      */


      LinenModel.prototype.route = function(options) {
        var _ref;

        if (arguments.length) {
          this._route = _.extend(this._route || {}, options);
          return this;
        }
        return _.extend({}, this._route, ((_ref = this.definition) != null ? _ref.options.$route : void 0) || {});
      };

      /*
      */


      LinenModel.prototype._set = function(key, value) {
        LinenModel.__super__._set.call(this, key, value);
        if (!this._update) {
          this._update = {};
        }
        return dref.set(this._update, key, this.get(key));
      };

      /*
       Hydrates the data and compares the current data to make sure this shit doesn't get overridden.
      */


      LinenModel.prototype.hydrate = function(data) {
        var cv, key, nv;

        for (key in data) {
          cv = this.get(key);
          nv = data[key];
          if (cv) {
            if (cv.__isBindable) {
              cv = cv.get("_id");
            } else if (cv.__isCollection) {
              delete data[key];
              continue;
            }
          }
          if (cv === nv) {
            delete data[key];
          }
        }
        this.set(data);
        this._update = {};
        return this;
      };

      /*
      */


      LinenModel.prototype.isNew = function() {
        return !this.get("_id");
      };

      /*
      */


      LinenModel.prototype.get = function() {
        this._initFetch();
        return LinenModel.__super__.get.apply(this, arguments);
      };

      /*
      */


      LinenModel.prototype.fetch = asyngleton(true, function(next) {
        var request;

        request = {
          method: "GET",
          item: this
        };
        if (this.isNew()) {
          return next(new Error("cannot fetch new model"));
        }
        return this._request(request, next);
      });

      /*
      */


      LinenModel.prototype._initFetch = function() {
        if (this._fetched || !this._initialized) {
          return;
        }
        this._fetched = true;
        return this.fetch();
      };

      /*
      */


      LinenModel.prototype._request = cstep(function(options, next) {
        var _this = this;

        options.item = this;
        options.one = true;
        linen.resource.request(options, outcome.e(next).s(function(result) {
          _this.hydrate(result);
          return next();
        }));
        return this;
      });

      /*
      */


      LinenModel.prototype._refs = function() {
        return this.schema.refs();
      };

      /*
      */


      LinenModel.prototype._setupRefs = function() {
        var ref, _i, _len, _ref, _results;

        this._refs = {};
        _ref = this.schema.refs();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ref = _ref[_i];
          _results.push(this._refs[ref.key] = ref);
        }
        return _results;
      };

      /*
       used for converting model objects into savable pieces - mostly for updating data
      */


      LinenModel.prototype._toObject = function(data) {
        var d, key, ref, v;

        d = {};
        for (key in data) {
          ref = this._refs[key];
          if (!(ref != null ? ref.options.$objectKey : void 0)) {
            v = data[key];
          } else {
            v = dref.get(data[key], ref.options.$objectKey);
          }
          d[key] = v;
        }
        return this._toJSON(d);
      };

      /*
      */


      LinenModel.prototype.save = function(next) {
        var o,
          _this = this;

        if (next == null) {
          next = (function() {});
        }
        o = this._o.e(next);
        this.validate(o.s(function() {
          if (_this.isNew()) {
            return _this._request({
              method: "POST",
              body: _this
            }, o.s(function() {
              _this.parent.pushNoPersist(_this);
              return next.call(_this);
            }));
          } else {
            return _this._request({
              method: "PUT",
              body: _this._toObject(_this._update)
            }, next);
          }
        }));
        return this;
      };

      /*
      */


      LinenModel.prototype.remove = function(next) {
        var _this = this;

        if (next == null) {
          next = (function() {});
        }
        if (this.isNew()) {
          next(new Error("cannot remove a new item"));
          return this;
        }
        this._request({
          method: "DELETE"
        }, outcome.e(next).s(function() {
          _this.removed = true;
          _this.emit("remove");
          _this.dispose();
          return next();
        }));
        return this;
      };

      return LinenModel;

    })(Model);
  };

}).call(this);

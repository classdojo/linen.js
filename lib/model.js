// Generated by CoffeeScript 1.6.2
(function() {
  var Model, bindable, dref, payload, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  bindable = require("bindable");

  _ = require("underscore");

  payload = require("./payload");

  dref = require("dref");

  Model = (function(_super) {
    __extends(Model, _super);

    /*
    */


    Model.prototype.__isModel = true;

    /*
    */


    function Model(schema) {
      this.schema = schema;
      Model.__super__.constructor.call(this, {});
      this._changed = {};
    }

    /*
    */


    Model.prototype.isNew = function() {
      return !this.has("_id");
    };

    /*
    */


    Model.prototype.hasChanged = function() {
      return !!Object.keys(this._changed);
    };

    /*
    */


    Model.prototype.changed = function() {
      return this._changed;
    };

    /*
    */


    Model.prototype.changedToArray = function() {
      var cha, key;

      cha = [];
      for (key in this._changed) {
        cha.push(this._changed[key]);
      }
      return cha;
    };

    /*
    */


    Model.prototype._set = function(key, value) {
      return Model.__super__._set.call(this, key, this.schema.map(key, value));
    };

    /*
    */


    Model.prototype.toJSON = function() {
      var data, field, value, _i, _len, _ref;

      data = {};
      _ref = this.schema.fields.toArray();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        field = _ref[_i];
        if (field.isVirtual()) {
          continue;
        }
        value = this.get(field.property);
        dref.set(data, field.property, (value != null ? typeof value.toJSON === "function" ? value.toJSON() : void 0 : void 0) || value);
      }
      return data;
    };

    /*
    */


    Model.prototype.flushChanged = function() {
      var changed;

      changed = this.changedToArray();
      this._changed = {};
      return changed;
    };

    /*
     refreshes the model
    */


    Model.prototype.fetch = function(next) {
      if (this.isNew()) {
        return next(new Error("cannot '" + this.schema.name + "' fetch on a new model"));
      }
      return this._fetch(payload.model(this).method("GET"), next);
    };

    /*
     saves the model - either adds it as a new one, or updates it
    */


    Model.prototype.save = function(next) {
      var _this = this;

      if (next == null) {
        next = function() {};
      }
      return this._fetch(payload.model(this).method(this.isNew() ? "POST" : "PUT").changed(this.flushChanged()), function() {
        next.apply(null, arguments);
        return _this.emit.apply(_this, ["save"].concat(__slice.call(arguments)));
      });
    };

    /*
     removes the model
    */


    Model.prototype.remove = function(next) {
      var _this = this;

      if (next == null) {
        next = function() {};
      }
      if (this.isNew()) {
        return next(new Error("cannot remove a new model"));
      }
      return this._fetch(payload.model(this).method("DELETE"), function(err) {
        next();
        return _this.emit("remove");
      });
    };

    /*
     calls .fetch() on schema, and updates this model
    */


    Model.prototype._fetch = function(payload, next) {
      var _this = this;

      if (next == null) {
        next = function() {};
      }
      this.schema.fetch(payload.data, function(err, result) {
        if (err != null) {
          return next(err);
        }
        _this.set(result || {});
        return next();
      });
      return this;
    };

    /*
     on binding, fetch this model, but don't do it all the time.
    */


    Model.prototype.bind = function(property) {
      var binding;

      binding = Model.__super__.bind.apply(this, arguments);
      if (this._ignoreFetch) {
        return binding;
      }
      this._throttledFetch();
      return binding;
    };

    /*
    */


    Model.prototype.validate = function(next) {
      var error;

      error = this.schema.validate(this);
      if (arguments.length === 1) {
        return next(error);
      } else {
        return error;
      }
    };

    /*
    */


    Model.prototype._throttledFetch = _.throttle((function() {
      return this.fetch();
    }), 1000 * 5);

    /*
    */


    Model.prototype._bindFields = function() {
      var field, fields, ignoreVirtuals, vfields, _fn, _fn1, _i, _j, _len, _len1,
        _this = this;

      this._ignoreFetch = true;
      ignoreVirtuals = {};
      fields = this.schema.fields.toArray();
      vfields = fields.filter(function(field) {
        return field.isVirtual();
      });
      _fn = function(field) {
        var fieldName, fops;

        fieldName = field.property;
        fops = field.options;
        return _this.bind(fieldName).to(function(newValue, oldValue) {
          if (field.options.ref && newValue) {
            newValue.owner = _this;
          }
          if (newValue != null ? newValue.__isCollection : void 0) {
            return;
          }
          _this._changed[fieldName] = {
            key: fieldName,
            nv: newValue,
            ov: oldValue
          };
          if (fops.set) {
            ignoreVirtuals[fieldName] = 1;
            fops.set(_this, newValue, oldValue);
            return delete ignoreVirtuals[fieldName];
          }
        }).now();
      };
      for (_i = 0, _len = fields.length; _i < _len; _i++) {
        field = fields[_i];
        _fn(field);
      }
      _fn1 = function(field) {
        var fieldName, fops, property, _k, _len2, _ref, _results;

        fieldName = field.property;
        fops = field.options;
        if (fops.get) {
          _this.set(field.property, fops.get(_this));
        }
        if (fops.bind) {
          _ref = fops.bind;
          _results = [];
          for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
            property = _ref[_k];
            _results.push((function(property) {
              return _this.bind(property).to(function() {
                if (ignoreVirtuals[fieldName]) {
                  return;
                }
                return _this.set(fieldName, fops.get(_this));
              });
            })(property));
          }
          return _results;
        }
      };
      for (_j = 0, _len1 = vfields.length; _j < _len1; _j++) {
        field = vfields[_j];
        _fn1(field);
      }
      return this._ignoreFetch = false;
    };

    return Model;

  })(bindable.Object);

  module.exports = Model;

}).call(this);

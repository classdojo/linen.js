// Generated by CoffeeScript 1.6.2
(function() {
  var Field, Model, Validator, async, bindable, dref, getFetcher, getJSONify, getMapper, outcome, payload, type, _;

  bindable = require("bindable");

  Model = require("./model");

  type = require("type-component");

  Validator = require("./validator");

  _ = require("underscore");

  dref = require("dref");

  outcome = require("outcome");

  async = require("async");

  getMapper = require("./map/factory");

  getFetcher = require("./fetch/factory");

  getJSONify = require("./jsonify/factory");

  payload = require("./payload");

  Field = (function() {
    /*
    */
    function Field(options) {
      var field, _i, _len, _ref;

      this.options = options;
      this.fields = options.fields;
      this.name = options.name;
      this.linen = options.linen;
      this.path = options.path;
      this.fieldNames = [];
      this._fieldsByKey = {};
      _ref = this.fields;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        field = _ref[_i];
        this._fieldsByKey[field.name] = field;
        this.fieldNames.push(field.name);
        field.parent = this;
      }
    }

    /*
    */


    Field.prototype.init = function() {
      var field, _i, _len, _ref;

      this._addAllFields(this.allFields = []);
      this.validator = new Validator(this);
      this.mapper = getMapper(this);
      this.fetcher = getFetcher(this);
      this.jsonifier = getJSONify(this);
      _ref = this.fields;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        field = _ref[_i];
        field.init();
      }
      return this;
    };

    /*
     returns a field
    */


    Field.prototype.getField = function(property, closest) {
      var field, path, _ref;

      if (property == null) {
        property = "";
      }
      if (closest == null) {
        closest = false;
      }
      path = property.split(".");
      field = this._fieldsByKey[path.shift()];
      if (field && path.length) {
        return (_ref = field.getField(path.join("."), closest)) != null ? _ref : closest ? field : void 0;
      } else {
        return field;
      }
    };

    /*
    */


    Field.prototype.getFields = function(fieldNames, closest) {
      var field, fields, property, _i, _len;

      if (closest == null) {
        closest = false;
      }
      fields = [];
      for (_i = 0, _len = fieldNames.length; _i < _len; _i++) {
        property = fieldNames[_i];
        field = this.getField(property, closest);
        if (!field || ~fields.indexOf(field)) {
          continue;
        }
        fields.push(field);
      }
      return fields;
    };

    /*
    */


    Field.prototype._addAllFields = function(allFields) {
      var field, _i, _len, _ref, _results;

      if (allFields == null) {
        allFields = [];
      }
      if (this.parent) {
        allFields.push(this);
      }
      _ref = this.fields;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        field = _ref[_i];
        _results.push(field._addAllFields(allFields));
      }
      return _results;
    };

    /*
     maps to the proper data type
     TODO - default, g/s
    */


    Field.prototype.map = function(model, data) {
      var field, _i, _len, _ref, _ref1;

      data = this.mapper.map(model, data);
      if (this.fields.length) {
        if (!data) {
          data = {};
        }
        _ref = this.fields;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          field = _ref[_i];
          data[field.name] = field.map(model, (_ref1 = data[field.name]) != null ? _ref1 : model.get(field.path));
        }
      }
      return data;
    };

    /*
    */


    Field.prototype.reset = function(model, data) {
      if (!this.parent) {
        return model.set(this.map(model, data));
      } else {
        return model.set(this.path, this.map(model, data));
      }
    };

    /*
    */


    Field.prototype.validate = function(data, next) {
      var _this = this;

      return this.validator.validate(data, function(err) {
        if (err) {
          err.message = "'" + _this.name + "' " + err.message;
          return next(err);
        }
        return async.forEach(_this.fields, (function(field, next) {
          return field.validate(dref.get(data, field.name), next);
        }), next);
      });
    };

    /*
    */


    Field.prototype.fetch = function(payload, next) {
      return this.fetcher.fetch(payload, next);
    };

    /*
    */


    Field.prototype.fetchAll = function(payload, next) {
      var _this = this;

      return this.fetch(payload, function(err) {
        if (err != null) {
          return next(err);
        }
        return async.forEach(_this.fields, (function(field, next) {
          return field.fetchAll(payload, next);
        }), next);
      });
    };

    /*
    */


    Field.prototype.load = function(model, next) {
      return this.fetch(payload.model(model).method("get").options, next);
    };

    /*
    */


    Field.prototype.loadAll = function(model, next) {
      var _this = this;

      return this.load(model, function(err) {
        if (err != null) {
          return next(err);
        }
        return async.forEach(_this.fields, (function(field, next) {
          return field.loadAll(model, next);
        }), next);
      });
    };

    /*
    */


    Field.prototype.loadField = function(model, name, next) {
      var f;

      if (!(f = this._field(name, next))) {
        return;
      }
      return f.load(model, next);
    };

    /*
    */


    Field.prototype._field = function(name, next) {
      var f;

      if (!(f = this.getField(name))) {
        next(new Error("field \"" + name + "\" doesn't exist"));
        return false;
      }
      return f;
    };

    /*
    */


    Field.prototype.toJSON = function(model, options) {
      var data, field, _i, _len, _ref;

      if (options == null) {
        options = {};
      }
      if (!options.fields) {
        options.fields = this.allFields;
      }
      data = {};
      _ref = options.fields;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        field = _ref[_i];
        field.jsonifier.writeJSON(model, data);
      }
      return data;
    };

    return Field;

  })();

  Field.parseOptions = function(definition, name, linen, path) {
    var fieldOps, ops, property, pt, t;

    if (path == null) {
      path = [];
    }
    ops = {};
    fieldOps = {
      name: name,
      linen: linen,
      path: path.join("."),
      fields: []
    };
    if ((t = type(definition)) === "array") {
      ops = definition[0];
      ops.$collection = true;
    } else if (t === "object") {
      _.extend(ops, definition);
    } else if (t === "string") {
      ops.$type = definition;
    }
    for (property in ops) {
      if (property.substr(0, 1) === "$") {
        fieldOps[property.substr(1)] = ops[property];
      } else {
        pt = path.concat(property);
        fieldOps.fields.push(new Field(Field.parseOptions(ops[property], property, linen, pt)));
      }
    }
    return fieldOps;
  };

  module.exports = Field;

}).call(this);

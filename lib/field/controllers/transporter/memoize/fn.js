// Generated by CoffeeScript 1.6.2
(function() {
  var Emitter, EventEmitter,
    __slice = [].slice;

  EventEmitter = require("events").EventEmitter;

  Emitter = (function() {
    /*
    */
    function Emitter() {
      this._listeners = {};
    }

    /*
    */


    Emitter.prototype.on = function(event, callback) {
      if (!this._listeners[event]) {
        this._listeners[event] = [];
      }
      return this._listeners[event].push(callback);
    };

    /*
    */


    Emitter.prototype.off = function(event, callback) {
      var i, listeners;

      if (!(listeners = this._listeners[event])) {
        return;
      }
      i = listeners.indexOf(callback);
      if (~i) {
        return listeners.splice(i, 1);
      }
    };

    /*
    */


    Emitter.prototype.once = function(event, callback) {
      var cb,
        _this = this;

      return this.on(event, cb = function() {
        var args;

        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        _this.off(event, cb);
        return callback.apply(null, args);
      });
    };

    /*
    */


    Emitter.prototype.emit = function(event) {
      var fnArgs, listeners;

      if (!(listeners = this._listeners[event])) {
        return;
      }
      fnArgs = Array.prototype.slice.call(arguments, 1);
      for(var i = listeners.length; i--;) { 
      listeners[i].apply(this, fnArgs);
    };
      return void 0;
    };

    return Emitter;

  })();

  module.exports = function(fn, ops) {
    var called, em, memoizedArgs;

    if (ops == null) {
      ops = {};
    }
    em = new Emitter();
    called = false;
    memoizedArgs = null;
    return function() {
      var args, cb,
        _this = this;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      cb = args.pop() || (function() {});
      if (memoizedArgs) {
        return cb.apply(null, memoizedArgs);
      }
      em.once("done", cb);
      if (called) {
        return;
      }
      called = true;
      args.push(function() {
        var args;

        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return setTimeout((function() {
          if (ops.store !== false) {
            memoizedArgs = args;
          } else {
            called = false;
          }
          em.emit.apply(em, ["done"].concat(__slice.call(args)));
          if (ops.maxAge) {
            return setTimeout((function() {
              return memoizedArgs = called = void 0;
            }), ops.maxAge);
          }
        }), 1);
      });
      fn.apply(this, args);
      return this;
    };
  };

}).call(this);
